- We have used GORM. It is slower than the standard database/sql. However GORM makes sure that errors are
  caught during complie time. 
- The standard database/sql package is fastest and allows maximum control over
  our queries. The sqlx package wraps around database/sql 
- While GORM provides full type safety, database/sql and sqlx does not. Errors are caught only at runtime
- sqlc comes in handy here. SQL queries are converted into Golang functions and any errors are caught
  during code generation or compile time. The only downside is that we need to do some setup initially

sql.yaml:
version: "1"
packages:
    - name: "db" --> name of go package
      path: "./db/sqlc" --> folder where generated golang code will live
      queries: "./db/query/" --> folder where sql queries live
      schema: "./db/migration/" --> folder where schemas are stored
      engine: "postgresql" --> mysql/postgresql
      emit_json_tags: true --> should the generated model struct contain json tags 
      emit_prepared_queries: false  --> should we used prepared sql statements for even faster performance
      emit_interface: false --> should we generate an interface called Querier for the generated db methods
      #emit_exact_tables_names: false --> should the model struct name be exactly the same as db table name

sqlc generate:
--> command to convert the sql code into generated golang funcs

-- name: DeleteAccount :exec
DELETE FROM accounts WHERE id = $1;

name: the name of the Golang query func 
:exec --> query func returns only error var
:one --> query func returns only one value 
:many --> query func returns multiple values 

Handling deadlocks:

- use FOR UPDATE at the end of SELECT queries to make it blocking until there is a COMMIT(and update)
- If we have another same SELECT query at the same time, it will be blocked until the other SELECT..FOR UPDATE commits
- For deadlocks we can pass a name to each transaction via the context (context.WithValue()) which takes a key value pair
- The key for ctx mustn't be an in built type, so u can use vat txKey = struct{}{}, nameVal can be fmt.Sprintf("tx %d", i)
- Inside the tx, you can obtain the name from the ctx and append it before each query like Print(txName, "Create transfer")
- This will show you the order of queries for concurrent transactions which you can replicate using SQL queries against db 
  manually, inside two txs. Run two such queries side by side to mock the deadlock test
- We found that one SELECT..FOR UPDATE (account) query was blocking an UPDATE on transfers table (in the other tx). 
  Why does SELECT..FOR UPDATE on one table require a block on UPDATE in transfers table? 
  Because of a foreign key connection between the tables. PSQL thinks the foreign key in transfers table(account_id) might also be 
  updated thats why SELECT was blocked in the second tx. 
SOLUTION:- SELECT * FROM accounts WHERE id = $1 LIMIT 1 FOR NO KEY UPDATE
  NO KEY UPDATE tells psql that in the next update query that we will execute, we will not be updating any keys, so psql won't lock it
BETTER QUERY: Check the AddAccountBalance() query 

Run these queries to check which processes and queries are causing the deadlock:
  https://wiki.postgresql.org/wiki/Lock_Monitoring

==================================================================================================

Transaction isolation levels: (I from ACID properties)
ISSUES:
- Dirty READ:
  A tx reads data written by other concurrent UNCOMMITTED tx 
- Non Repeatable Read:
  A tx reads the same row twice, and sees different value because it has been modified by other COMMITTED tx 
- Phantom Read:
  A tx re-executes a query to find rows that satisfy a condition and sees a different set of rows, due to changes 
  by other COMMITTED tx 
- Serialization Anomaly:
  The result of a group of concurrent COMMITTED txs is impossible to achieve if we try to run them sequentially
  in any order without overlapping

4 Standard Isolation Levels: (lowest to highest)
- Read Uncommitted:
  can see data written by other uncommitted tx 

- Read Committed: (prevents dirty read only)
  Only see data written by committed tx (fixes Dirty Read)
  If we have two concurrent txs updating the same row, we will be able to see the update made by tx1 inside tx2
  only after tx1 has COMMITTED

- Repeatable Read: (prevents dirty read, non repeatable read, phantom read)
  Same read query always returns the same result (fixes Phantom Read)
  Lets say we have two concurrent txs, selecting and updating balance from acc1; Before both tx started, lets say 
  balance was 80. Now if in tx1 we update balance to 70, and committ it, mind you tx2 is still running, uncommitted.
  If we select acc1 balance from tx2, we will still see old balance of 80. This ensures that in a tx, isolation is 
  achieved from other txs. However if we were to update balance in tx2 after tx1 has committed, it will take into
  account updated balance from tx1 as that has already committed. This is peculiar to MySQL

  In PSQL, in this isolation level, tx2 will not be allowed to update acc1. CONCURRENT updates are not allowed.

- Serializeable: (prevents all read errors)
  Can achieve same result if we execute txs serially in some order instead of concurrently (fixes Serialization Anomaly).
  In the same scenario as above, we set isolation level to Serializeable. If we select acc1 from tx2 and try updating 
  acc1 balance from tx1, the update will be blocked as MySQL automatically sets SELECT queries to SELECT..FOR SHARE, like 
  psql SELECT..FOR UPDATE in Serializeable Isolation Level. This can also create a DEADLOCK so each tx has a timeout. This 
  is where ORDER of queries becomes important
  Another example: In tx1 we run an insert statement, and in tx2 we run the same insert concurrently. In Repeatable Read lvl,
  we will get two identical rows in the db after both txs commit.
  However in Serializeable Isolation Level, this same thing will return an error when the last tx is committed. However PSQL 
  will give us a hint that it might succeed if we retried
  In MySQL, if we run identical queries in 2 concurrent txes, even select will be blocked(if there is an insert or update 
  in the other tx), using a locking mechanism