- We have used GORM. It is slower than the standard database/sql. However GORM makes sure that errors are
  caught during complie time. 
- The standard database/sql package is fastest and allows maximum control over
  our queries. The sqlx package wraps around database/sql 
- While GORM provides full type safety, database/sql and sqlx does not. Errors are caught only at runtime
- sqlc comes in handy here. SQL queries are converted into Golang functions and any errors are caught
  during code generation or compile time. The only downside is that we need to do some setup initially

sql.yaml:
version: "1"
packages:
    - name: "db" --> name of go package
      path: "./db/sqlc" --> folder where generated golang code will live
      queries: "./db/query/" --> folder where sql queries live
      schema: "./db/migration/" --> folder where schemas are stored
      engine: "postgresql" --> mysql/postgresql
      emit_json_tags: true --> should the generated model struct contain json tags 
      emit_prepared_queries: false  --> should we used prepared sql statements for even faster performance
      emit_interface: false --> should we generate an interface called Querier for the generated db methods
      #emit_exact_tables_names: false --> should the model struct name be exactly the same as db table name

sqlc generate:
--> command to convert the sql code into generated golang funcs

-- name: DeleteAccount :exec
DELETE FROM accounts WHERE id = $1;

name: the name of the Golang query func 
:exec --> query func returns only error var
:one --> query func returns only one value 
:many --> query func returns multiple values 

Handling deadlocks:

- use FOR UPDATE at the end of SELECT queries to make it blocking until there is a COMMIT(and update)
- If we have another same SELECT query at the same time, it will be blocked until the other SELECT..FOR UPDATE commits
- For deadlocks we can pass a name to each transaction via the context (context.WithValue()) which takes a key value pair
- The key for ctx mustn't be an in built type, so u can use vat txKey = struct{}{}, nameVal can be fmt.Sprintf("tx %d", i)
- Inside the tx, you can obtain the name from the ctx and append it before each query like Print(txName, "Create transfer")
- This will show you the order of queries for concurrent transactions which you can replicate using SQL queries against db 
  manually, inside two txs. Run two such queries side by side to mock the deadlock test
- We found that one SELECT..FOR UPDATE (account) query was blocking an UPDATE on transfers table (in the other tx). 
  Why does SELECT..FOR UPDATE on one table require a block on UPDATE in transfers table? 
  Because of a foreign key connection between the tables. PSQL thinks the foreign key in transfers table(account_id) might also be 
  updated thats why SELECT was blocked in the second tx. 
SOLUTION:- SELECT * FROM accounts WHERE id = $1 LIMIT 1 FOR NO KEY UPDATE
  NO KEY UPDATE tells psql that in the next update query that we will execute, we will not be updating any keys, so psql won't lock it
BETTER QUERY: Check the AddAccountBalance() query 

Run these queries to check which processes and queries are causing the deadlock:
  https://wiki.postgresql.org/wiki/Lock_Monitoring